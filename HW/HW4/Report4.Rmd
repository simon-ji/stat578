---
title: "STAT 578 - Advanced Bayesian Modeling - Fall 2019  Assignment 4"
author: "Xiaoming Ji"
output:
  pdf_document: default
---
## Solution for Problem (a)
### (i)
According to the formular for Moore's law and take log on T, we get:

$log(T) \approx log(C * 2 ^{A/2}) \rightarrow log(T) \approx log(C) + 0.3465736 * A$

This is the form of linear regression that make logT as response variable and A as explanatory variable. `log(C)` is the intercept and coefficient of A is 0.3465736. Thus we can say logT is roughly follow a simple linear regression on A.

### (ii)
```{r}
moores_df = read.csv("mooreslawdata.csv", header=TRUE)
with(moores_df, plot(log(Transistors) ~ Year))
```

## Solution for Problem (b)
### (i)
```{r eval=FALSE, include=TRUE}
model {
  for (i in 1:length(y)) {
  y[i] ~ dnorm(beta1 + beta2*A_CENTERED[i], sigmasqinv)
  }
  beta1 ~ dnorm(0, 1e-06)
  beta2 ~ dnorm(0, 1e-06)
  sigmasqinv ~ dgamma(0.001, 0.001)
  sigmasq <- 1/sigmasqinv
}
```

```{r}
df <- list(y = log(moores_df$Transistors),
           A_CENTERED = moores_df$Year - mean(moores_df$Year))

lm_model = lm(y ~ A_CENTERED, data=df)
summary(lm_model)
```

- $\beta$ estimates are about 0.3 to 18, we choose to set initial $\beta$ values at $\pm200$
- Regression error variance $\sigma^2$ estimate is about $(0.94^2) \approx 0.9$, we choose to set initial $\sigma^2$ values of 0.01 and 100

```{r include=FALSE}
library(rjags)

initial_vals <- list(list(beta1 = 200, beta2 = 200, sigmasqinv = 100),
                     list(beta1 = 200, beta2 = -200, sigmasqinv = 100),
                     list(beta1 = -200, beta2 = 200, sigmasqinv = 0.01),
                     list(beta1 = -200, beta2 = -200, sigmasqinv = 0.01))

moores_model <- jags.model("moores.bug", df, initial_vals, n.chains = 4)
update(moores_model, 1000)
coef_sample <- coda.samples(moores_model, c("beta1","beta2","sigmasq"), n.iter=2000)
```
```{r}
gelman.diag(coef_sample, autoburnin=FALSE)
```
Gelman-Rubin statistic for $\beta1$, $\beta2$ and $\sigma^2$ are all 1, thus we can declare convergence of them.


### (ii)
```{r}
summary(coef_sample)
```

### (iii)
```{r}
beta2_sample = as.matrix(coef_sample)[,"beta2"]
```
Mean of slope, 
```{r}
mean(beta2_sample)
```

95% posterior credible interval of slope,
```{r}
quantile(beta2_sample, c(0.025, 0.975)) 
```

The interval contains value (0.3465736) determined in part (a).

### (iv)
```{r}
beta1_sample = as.matrix(coef_sample)[,"beta1"]
```
Mean of intercept, 
```{r}
mean(beta1_sample)
```

95% posterior credible interval of intercept,
```{r}
quantile(beta1_sample, c(0.025, 0.975)) 
```


## Solution for Problem (c)
## Solution for Problem (d)
